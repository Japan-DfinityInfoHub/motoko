<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/errors.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/errors.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#エラーと-option">エラーと Option</a>
<ul>
<li><a href="#api-の例">API の例</a></li>
<li><a href="#問題が起こる場合">問題が起こる場合</a></li>
<li><a href="#どのようなエラー型が良いか">どのようなエラー型が良いか</a>
<ul>
<li><a href="#どうすべき-ではない-のか">どうすべき <em>ではない</em>
のか</a></li>
<li><a
href="#可能であれば例外よりも-optionresult-を優先する">可能であれば、例外よりも
Option/Result を優先する</a></li>
<li><a href="#option-によるエラー通知">Option によるエラー通知</a></li>
<li><a href="#result-型によるエラーリポート"><code>Result</code>
型によるエラーリポート</a></li>
</ul></li>
<li><a href="#optionresult-を使用する">Option/Result を使用する</a>
<ul>
<li><a href="#パターンマッチング">パターンマッチング</a></li>
<li><a href="#高階関数">高階関数</a></li>
<li><a href="#option-と-result-の相互変換">Option と Result
の相互変換</a></li>
</ul></li>
<li><a href="#非同期エラー">非同期エラー</a></li>
</ul></li>
</ul>
</nav>
<h1 id="エラーと-option">エラーと Option</h1>
<p>Motoko では、エラー値を表現し処理するための方法が主に 3
つあります。</p>
<ul>
<li><p>Option 値（<em>何らかの</em> エラーを示す、情報を持たない
<code>null</code> 値を含む）</p></li>
<li><p><code>Result</code>
のバリアント（エラーに関する詳細な情報を提供する <code>#err 値</code>
の記述を含む）</p></li>
<li><p><code>Error</code>
値（非同期コンテキストでは、例外処理のようにスロー（throw）したりキャッチ（catch）したりすることができ、数値コードとメッセージを含む）</p></li>
</ul>
<h2 id="api-の例">API の例</h2>
<p>Todo アプリケーションの API を構築していると想定し、ユーザーが Todo
の 1 つに <strong>Done</strong>
という印を付ける関数を公開したいとします。
問題をシンプルにするために、<code>TodoId</code> を受け取り、Todo
を開いてから何秒経ったかを表す <code>Int</code> を返すことにします。
また、自分自身の Actor
で実行していると仮定し、非同期の値を返すことにします。
問題が一切起きないとすると、次のような API になります。</p>
<pre class="motoko"><code>func markDone(id : TodoId) : async Int</code></pre>
<p>参照のため、このドキュメント内で使用する全ての型とヘルパー関数の全体記述を示します。</p>
<pre class="motoko"><code></code></pre>
<pre class="motoko"><code></code></pre>
<h2 id="問題が起こる場合">問題が起こる場合</h2>
<p>ここで、Todo
に完了の印をつける処理が失敗する条件があることに気がつきました。</p>
<ul>
<li><p><code>id</code> が存在しない Todo
に紐づけられている可能性がある</p></li>
<li><p>Todo にすでに完了の印がついている可能性がある</p></li>
</ul>
<p>これから Motoko
でこれらのエラーを取り扱う様々な方法について示し、コードを徐々に改善していきます。</p>
<h2 id="どのようなエラー型が良いか">どのようなエラー型が良いか</h2>
<h3 id="どうすべき-ではない-のか">どうすべき <em>ではない</em> のか</h3>
<p>エラーを報告する簡単で <em>良くない</em> 方法の一つは、<em>番兵
（Sentinel）</em> を使用することです。例えば、 <code>markDone</code>
関数において <code>-1</code>
という値を使用して、何かが失敗したことを通知することにします。その場合、呼び出し側は戻り値をこの特別な値と照らし合わせてエラーを報告しなければなりません。しかし、エラー状態をチェックせずに、その値を使ってその後の処理を続けることはあまりにも簡単です。
これは、エラーの検出を遅らせたり見逃したりすることにつながるので、必ず避けるべきです。</p>
<p>定義：</p>
<pre class="motoko"><code></code></pre>
<p>呼び出し側：</p>
<pre class="motoko"><code></code></pre>
<h3
id="可能であれば例外よりも-optionresult-を優先する">可能であれば、例外よりも
Option/Result を優先する</h3>
<p>Motoko では、エラーを通知する方法として <code>Option</code> や
<code>Result</code> を使用することが推奨されています。
これらは同期・非同期のどちらのコンテキストでも動作し、API
をより安全に使用することができます
（成功と同様にエラーも考慮するようにクライアントに促すことができます）。
例外は、予期しないエラー状態を通知するためにのみ使用されるべきです。</p>
<h3 id="option-によるエラー通知">Option によるエラー通知</h3>
<p><code>A</code>
型の値を返すかそうでなければエラー通知を行いたい関数は、 <em>Option</em>
型の <code>?A</code> の値を返し、 <code>null</code>
値を使用してエラーを指定することができます。
今の例では、<code>markDone</code> 関数が <code>async ?Seconds</code>
を返すことを意味します。</p>
<p>以下は、 <code>markDone</code> 関数の例です。</p>
<p>定義：</p>
<pre class="motoko"><code></code></pre>
<p>呼び出し側：</p>
<pre class="motoko"><code></code></pre>
<p>この方法の主な欠点は、起こりうるすべてのエラーを、情報を持たない一つの
<code>null</code> 値にひとまとめにしてしまうことです。 呼び出し側は
<code>Todo</code>
を完了させることに失敗した理由に興味があるかもしれませんが、その情報は失われています。つまり、ユーザーには
<code>"何かがうまくいかなかった"</code> としか伝えられません。
エラーを知らせるために Option 値を返すのは、失敗の原因が 1
つだけで、その原因が呼び出し側で容易に判断できる場合だけにすべきです。
この良い使用例のひとつは、HashMap の参照に失敗した場合です。</p>
<h3 id="result-型によるエラーリポート"><code>Result</code>
型によるエラーリポート</h3>
<p>エラーを知らせるために Option
型を使用することの欠点を解決するために、今度はより多機能な
<code>Result</code> 型を見てみましょう。 Option は組み込みの型ですが、
<code>Result</code>
は以下のようにバリアント型として定義されています。</p>
<pre class="motoko"><code>type Result&lt;Ok, Err&gt; = { #ok : Ok; #err : Err }</code></pre>
<p>2 つ目の型引数である <code>Err</code> により、<code>Result</code>
型ではエラーを記述するために使用する型を選択することができます。
そこで、<code>markDone</code> 関数がエラーを通知するために使用する
<code>TodoError</code> 型を定義することにします。</p>
<pre class="motoko"><code></code></pre>
<p>これを用いて <code>markDone</code> の 3
つ目のバージョンを書きます。</p>
<p>定義：</p>
<pre class="motoko"><code></code></pre>
<p>呼び出し側：</p>
<pre class="motoko"><code></code></pre>
<p>ご覧の通り、ユーザーに役立つエラーメッセージを表示することができるようになりました。</p>
<h2 id="optionresult-を使用する">Option/Result を使用する</h2>
<p><code>Option</code> と <code>Results</code>
は、（あなたがいたる所で例外処理を行うようなプログラミング言語から来た場合は特に）エラーについて異なる考え方をすることになります。
この章では、<code>Option</code> と <code>Results</code>
を作成、再構築、変換、結合するさまざまな方法を見ていきます。</p>
<h3 id="パターンマッチング">パターンマッチング</h3>
<p>最初の、そして最も一般的な <code>Option</code> と <code>Result</code>
の使用場面はパターンマッチングです。 <code>?Text</code>
型の値があるとき、<code>switch</code> キーワードを使って潜在する
<code>Text</code> の値にアクセスすることができます。</p>
<pre class="motoko"><code></code></pre>
<p>ここで理解すべき重要なことは、Motoko は Option
の値にアクセスするときは必ず、値が見つからない場合を考慮させるということです。</p>
<p><code>Result</code>
の場合もパターンマッチングを使うことができます。ただし、<code>#err</code>
の場合は、（単なる <code>null</code>
ではなく）情報を持つ値も取得できるという違いがあります。</p>
<pre class="motoko"><code></code></pre>
<h3 id="高階関数">高階関数</h3>
<p>パターンマッチングは、複数の Option
値を扱う場合は特に、退屈で冗長になることがあります。 <a
href="https://github.com/dfinity/motoko-base">Motoko 標準ライブラリ</a>
は、<code>Optional</code> と <code>Result</code>
モジュールの高階関数群を公開することで、エラー処理を人間工学的に改善します。</p>
<h3 id="option-と-result-の相互変換">Option と Result の相互変換</h3>
<p>Option と Result の間を行ったり来たりしたいことがあります。 例えば
HashMap の参照に失敗すると <code>null</code>
が返され、それはそれで良いのですが、呼び出し元はより多くのコンテキストを持っていて、その検索の失敗を意味のある
<code>Result</code> に変換できるかもしれません。
他には、<code>Result</code> が提供する追加情報は必要なく、単にすべての
<code>#err</code> ケースを <code>null</code>
に変換したいという場面もあります。 このような場合のために、 <a
href="https://github.com/dfinity/motoko-base">Motoko 標準ライブラリ</a>
では <code>Result</code> モジュールに <code>fromOption</code> と
<code>toOption</code> という関数を用意しています。</p>
<h2 id="非同期エラー">非同期エラー</h2>
<p>Motoko でエラーを処理する最後の方法は、非同期の <code>Error</code>
処理を使うことです。これは他の言語でおなじみの例外処理に制限を設けたものです。
他の言語の例外処理とは異なり、Motoko の <em>エラー</em> の値は
<code>shared</code> 関数または <code>async</code>
式の本体といった非同期コンテキストでのみ、スロー（throw）とキャッチ（catch）を行うことができます。非
<code>shared</code> 関数は構造化されたエラー処理を行うことができません。
つまり、<code>throw</code> でエラー値を投げて <code>shared</code>
関数を終了したり、<code>try</code> で別の Actor 上の <code>shared</code>
関数を呼び出して失敗を <code>Error</code> 型で <code>catch</code>
することはできますが、これらのエラー処理を非同期のコンテキスト以外の通常のコードで使用することはできません。</p>
<p>非同期の <code>Error</code>
は一般的に、回復できないような予期しない失敗を知らせる目的で、かつあなたの
API
を多くの人が利用しない場合にのみ使用されるべきです。もし失敗が呼び出し側で処理されるべきものであれば、代わりに
<code>Result</code>
を返すことで、シグネチャ（signature）でそれを明示する必要があります。完全を期すために、例外を含む
<code>markDone</code> の例を以下に示します。</p>
<p>定義：</p>
<pre class="motoko"><code></code></pre>
<p>呼び出し側：</p>
<pre class="motoko"><code></code></pre>
<!--
# Errors and Options

There are three primary ways to represent and handle errors values in Motoko:

-   Option values (with a non-informative `null` indicated *some* error);

-   `Result` variants (with a descriptive `#err value` providing more information about the error); and

-   `Error` values (that, in an asynchronous context, can be thrown and caught - similar to exceptions - and contain a numeric code and message).

## Our Example API

Let’s assume we’re building an API for a Todo application and want to expose a function that lets a user mark one of their Todo’s as **Done**. To keep it simple we’ll accept a `TodoId` and return an `Int` that represents how many seconds the Todo has been open. We’re also assuming we’re running in our own actor so we return an async value. If nothing would ever go wrong that would leave us with the following API:

``` motoko no-repl
func markDone(id : TodoId) : async Int
```

The full definition of all types and helpers we’ll use in this document is included for reference:

``` motoko no-repl file=./examples/todo-error.mo#L1-L6
```

``` motoko no-repl file=./examples/todo-error.mo#L10-L37
```

## When things go wrong

We now realize that there are conditions under which marking a Todo as done fails.

-   The `id` could reference a non-existing Todo

-   The Todo might already be marked as done

We’ll now talk about the different ways to communicate these errors in Motoko and slowly improve our solution.

## What error type to prefer

### How *not* to do things

One particularly easy and *bad* way of reporting errors is through the use of a *sentinel* value. For example, for our `markDone` function we might decide to use the value `-1` to signal that something failed. The callsite then has to check the return value against this special value and report the error. But it’s way too easy to not check for that error condition and continue to work with that value in our code. This can lead to delayed or even missing error detection and is strongly discouraged.

Definition:

``` motoko no-repl file=./examples/todo-error.mo#L38-L47
```

Callsite:

``` motoko no-repl file=./examples/todo-error.mo#L108-L115
```

### Prefer Option/Result over Exceptions where possible

Using `Option` or `Result` is the preferred way of signaling errors in Motoko. They work in both synchronous and asynchronous contexts and make your APIs safer to use (by encouraging clients to consider the error cases as well as the success cases. Exceptions should only be used to signal unexpected error states.

### Error reporting with Option

A function that wants to return a value of type `A` or signal an error can return a value of *option* type `?A` and use the `null` value to designate the error. In our example this means having our `markDone` function return an `async ?Seconds`.

Here’s what that looks like for our `markDone` function:

Definition:

``` motoko no-repl file=./examples/todo-error.mo#L49-L58
```

Callsite:

``` motoko no-repl file=./examples/todo-error.mo#L117-L126
```

The main drawback of this approach is that it conflates all possible errors with a single, non-informative `null` value. Our callsite might be interested in why marking a `Todo` as done has failed, but that information is lost by then, which means we can only tell the user that `"Something went wrong."`. Returning option values to signal errors should only be used if there just one possible reason for the failure, and that reason can be easily determined at the callsite. One example of a good usecase for this is a HashMap lookup failing.

### Error reporting with `Result` types

To address the shortcomings of using option types to signal errors we’ll now look at the richer `Result` type. While options are a built-in type, the `Result` is defined as a variant type like so:

``` motoko no-repl
type Result<Ok, Err> = { #ok : Ok; #err : Err }
```

Because of the second type parameter, `Err`, the `Result` type lets us select the type we use to describe errors. So we’ll define a `TodoError` type our `markDone` function will use to signal errors.

``` motoko no-repl file=./examples/todo-error.mo#L60-L60
```

This lets us now write the third version of `markDone`:

Definition:

``` motoko no-repl file=./examples/todo-error.mo#L62-L76
```

Callsite:

``` motoko no-repl file=./examples/todo-error.mo#L128-L141
```

And as we can see we can now give the user a useful error message.

## Working with Option/Result

`Option`s and `Results`s are a different way of thinking about errors, especially if you come from a language with pervasive exceptions. In this chapter we’ll look at the different ways to create, destructure, convert, and combine `Option`s and `Results` in different ways.

### Pattern matching

The first and most common way of working with `Option` and `Result` is to use 'pattern matching'. If we have a value of type `?Text` we can use the `switch` keyword to access the potential `Text` contents:

``` motoko no-repl file=./examples/error-examples.mo#L3-L10
```

The important thing to understand here is that Motoko does not let you access the optional value without also considering the case that it is missing.

In the case of a `Result` we can also use pattern matching, with the difference that we also get an informative value (not just `null`) in the `#err` case.

``` motoko no-repl file=./examples/error-examples.mo#L12-L19
```

### Higher-Order functions

Pattern matching can become tedious and verbose, especially when dealing with multiple optional values. The [base](https://github.com/dfinity/motoko-base) library exposes a collection of higher-order functions from the `Optional` and `Result` modules to improve the ergonomics of error handling.

### Converting back and forth between Option/Result

Sometimes you’ll want to move between Options and Results. A Hashmap lookup returns `null` on failure and that’s fine, but maybe the caller has more context and can turn that lookup failure into a meaningful `Result`. At other times you don’t need the additional information a `Result` provides and just want to convert all `#err` cases into `null`. For these situations [base](https://github.com/dfinity/motoko-base) provides the `fromOption` and `toOption` functions in the `Result` module.

## Asynchronous Errors

The last way of dealing with errors in Motoko is to use asynchronous `Error` handling, a restricted form of the exception handling familiar from other languages. Unlike the exceptions of other languages, Motoko *errors* values, can only be thrown and caught in asynchronous contexts, typically the body of a `shared` function or `async` expression. Non-`shared` functions cannot employ structured error handling. This means you can exit a shared function by `throw`ing an `Error` value and `try` some code calling a shared function on another actor, `catch`ing its failure as a result of type `Error`, but you can’t use these error handling constructs in regular code, outside of an asynchronous context.

Asynchronous `Error`s should generally only be used to signal unexpected failures that you cannot recover from, and that you don’t expect many consumers of your API to handle. If a failure should be handled by your caller you should make it explicit in your signature by returning a `Result` instead. For completeness here is the `markDone` example with exceptions:

Definition:

``` motoko no-repl file=./examples/todo-error.mo#L78-L92
```

Callsite:

``` motoko no-repl file=./examples/todo-error.mo#L143-L150
```

-->
</body>
</html>
