<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/motoko.md</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/motoko.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a
href="#motoko-programming-language-motoko-プログラミング言語">Motoko
Programming Language# Motoko プログラミング言語</a>
<ul>
<li><a
href="#ネイティブ-canister-スマートコントラクトサポート">ネイティブ
Canister スマートコントラクトサポート</a></li>
<li><a
href="#ダイレクトスタイルでシーケンシャルにコードを書く">ダイレクトスタイルでシーケンシャルにコードを書く</a></li>
<li><a href="#現代的な型システム">現代的な型システム</a></li>
<li><a href="#自動生成の-idl-ファイル">自動生成の IDL ファイル</a></li>
<li><a href="#直交永続性">直交永続性</a></li>
<li><a href="#アップグレード">アップグレード</a></li>
<li><a href="#さらなる機能">さらなる機能</a></li>
</ul></li>
</ul>
</nav>
<h1 id="motoko-programming-language-motoko-プログラミング言語">Motoko
Programming Language# Motoko プログラミング言語</h1>
<p>:::tip</p>
<p>Motoko プログラミング言語は、 DFINITY Canister SDK のリリースや、
Motoko コンパイラのアップデートを経て進化を続けています。
新しい機能を試したり、何が変わったのかを知るために、定期的に戻って確認しに来ましょう。</p>
<p>:::</p>
<p>Motoko プログラミング言語は、Internet Computer
ブロックチェーンネットワーク上で動く次世代の Dapps
をビルドしたい開発者のための、新しく現代的で型安全な言語です。 Motoko
は、Internet Computer
のユニークな機能をサポートし、親しみやすいけど頑丈なプログラミング環境を提供するよう、特別に設計されています。
新しい言語として Motoko
は、新たな機能や改善のサポートを経て進化し続けています。</p>
<p>Motoko コンパイラ、ドキュメント、また他のツールは、 <a
href="https://github.com/dfinity/motoko">オープンソース</a>
であり、Apache 2.0
ライセンスのもとでリリースされています。コントリビュートは歓迎です。</p>
<h2 id="ネイティブ-canister-スマートコントラクトサポート">ネイティブ
Canister スマートコントラクトサポート</h2>
<p>Motoko は、Internet Computer Canister
スマートコントラクトをネイテイブサポートしています。</p>
<p>Canister スマートコントラクト (または略して Canister) は、 Motoko
Actor として表されます。 Actor
とは、そのステートを完全にカプセル化して、非同期メッセージでのみ別の
Actor との通信を行う自律的なオブジェクトです。</p>
<pre class="motoko"><code></code></pre>
<h2
id="ダイレクトスタイルでシーケンシャルにコードを書く">ダイレクトスタイルでシーケンシャルにコードを書く</h2>
<p>Internet Computer 上では、Canisters は他の Canisters
と非同期のメッセージを送ることでコミュニケーションができます。</p>
<p>非同期のプログラミングは難しいので、Motoko
はより単純なシーケンシャルスタイルでコードを書くことを可能にしています。非同期のメッセージは
<em>future</em> を返す関数呼び出しであり、<code>await</code>
コンストラクトは future
が完了するまで処理を延期することを許可します。この単純な機能は、他の言語でも不適切である非同期プログラミングでの"コールバック地獄"を回避します。</p>
<pre class="motoko"><code></code></pre>
<h2 id="現代的な型システム">現代的な型システム</h2>
<p>Motoko は、JavaScript
や他の有名言語と直感的に馴染みやすくなるよう設計されていますが、構造的型、ジェネリクス、バリアント型、または静的なパターンマッチングのような現代的な機能も提供します。</p>
<pre class="motoko"><code></code></pre>
<h2 id="自動生成の-idl-ファイル">自動生成の IDL ファイル</h2>
<p>Motoko Actor
は、引数と返り値の型を示す関数として、常に型付けされたインターフェースをクライアントに、提供しています。</p>
<p>Motoko コンパイラー（かつ SDK ）は、Candid
と呼ばれる言語に依存しないフォーマットでこのインターフェースを出力するので、Candid
をサポートしている別の Canisters
やブラウザ上のコードやスマートフォンアプリは、Actor
のサービスを利用することができます。Motoko コンパイラは、Candid
ファイルを使用したり生成したりすることができ、Motoko にシームレスに（
Candid をサポートしている）他の言語で実装された Canister
と接続することを可能にします。</p>
<p>例えば、上で示した Motoko の <code>Counter</code> Actor は、次に続く
Candid インターフェースを持っています。</p>
<pre class="candid"><code>service Counter : {
  inc : () -&gt; (nat);
}</code></pre>
<h2 id="直交永続性">直交永続性</h2>
<p>Internet Computer は、作動している Canister
のメモリと他のステートも保持しています。それゆえ、Motoko Actor
のステートは、そのインメモリデータ構造も含め永久に残り続けます。Actor
のステートは、それぞれのメッセージと共に復元することや外部ストレージに保存することを明確に必要としていません。</p>
<p>例えば、シーケンシャルな ID をテキストの名前に割り当てる次の
<code>Registry</code> Actor (Canister) では、Actor
のステートがたくさんの Internet Computer
ノードマシーンで複製されたもので、一般的にメモリ内にはいないれども、ハッシュテーブルのステートはコールを介して保存されています。</p>
<pre class="motoko"><code></code></pre>
<h2 id="アップグレード">アップグレード</h2>
<p>Motoko は、Canister のコードをアップグレードするとき Canister
のデータを保持できることを許可する言語機能を含めた、直交永続性を活用するのを助ける数多くの機能を提供しています。</p>
<p>例えば、Motoko は、ある変数を <code>stable</code>
として宣言することができます。 <code>stable</code> 変数の値は、 Canister
アップグレードでも自動的に保持されます。</p>
<p>stable カウンターを考えてみましょう。</p>
<pre class="motoko"><code></code></pre>
<p>インストール後に <em>n</em>
回インクリメントされ、その後中断することなく、より多機能な実装へとアップグレードすることができます。</p>
<pre class="motoko"><code></code></pre>
<p><code>value</code> は <code>stable</code>
として宣言されていたので、現在のステートやサービスの n
はアップグレードの後でも保持されています。カウンティングは、0
から再度始まるのではなく、n 回目から始まります。</p>
<p>その新しいインターフェースは過去のものと互換性がありますので、既に存在している
Canister
に関するクライアントは動作を続けていきますが、新しいクライアントは、アップグレードした機能を最大限利用することもできます。（追加の
<code>reset</code> 機能）</p>
<p>stable な変数の使用のみでは解決できないシナリオのために、Motoko
は、アップグレードの前後で即座に動作するかつ任意のステートを静的な変数にすることを許可する、ユーザーが定義できるアップグレードフックを提供しています。</p>
<h2 id="さらなる機能">さらなる機能</h2>
<p>Motoko
は、サブタイピング、任意精度演算、またはガベージコレクションを含めた、多くの開発者の生産性を上げる機能を提供しています。</p>
<p>Motoko は、スマートコントラクト Canister
を導入するためだけの言語ではなく、またそうであることを意図していません。もしあなたのニーズを満たさない時のために、Rust
プログラミング言語の CDK があります。 私達の目標は、言語に左右されない
Candid インターフェースを通し、他国の Canister
スマートコントラクトと一緒に Internet Computer 上で動作する Canister
スマートコントラクトを、いかなる言語でも作成できるようにすることです。</p>
<p>そのオーダーメイド設計は、少なくともしばらくの間 Motoko が Internet
Computer
上でのコーディングにおいて最も簡単かつ安全な言語であろうことを意味しています。</p>
<!--

:::tip

The Motoko programming language continues to evolve with each release of the DFINITY Canister SDK and with ongoing updates to the Motoko compiler. Check back regularly to try new features and see what’s changed.

:::

The Motoko programming language is a new, modern and type safe language for developers who want to build the next generation of distributed applications to run on the Internet Computer blockchain network. Motoko is specifically designed to support the unique features of the Internet Computer and to provide a familiar yet robust programming environment. As a new language, Motoko is constantly evolving with support for new features and other improvements.

The Motoko compiler, documentation and other tooling is [open source](https://github.com/dfinity/motoko) and released under the Apache 2.0 license. Contributions are welcome.

## Native canister smart contract support

Motoko has native support for Internet Computer canister smart contracts.

A canister smart contract (or canister for short) is expressed as a Motoko actor. An actor is an autonomous object that fully encapsulates its state and communicates with other actors only through asynchronous messages.

For example, this code defines a stateful `Counter` actor.

``` motoko name=counter file=./examples/Counter.mo
```

Its single public function, `inc()`, can be invoked by this and other actors, to both update and read the current state of its private field `value`.

## Code sequentially in direct style

On the Internet Computer, canisters can communicate with other canisters by sending asynchronous messages.

Asynchronous programming is hard, so Motoko enables you to author asynchronous code in much simpler, sequential style. Asynchronous messages are function calls that return a *future*, and the `await` construct allows you to suspend execution until a future has completed. This simple feature avoids the "callback hell" of explicit asynchronous programming in other languages.

``` motoko include=counter file=./examples/factorial.mo#L9-L21
```

## Modern type system

Motoko has been designed to be intuitive to those familiar with JavaScript and other popular languages, but offers modern features such as sound structural types, generics, variant types, and statically checked pattern matching.

``` motoko file=./examples/tree.mo
```

## Autogenerated IDL files

A Motoko actor always presents a typed interface to its clients as a suite of named functions with argument and (future) result types.

The Motoko compiler (and SDK) can emit this interface in a language neutral format called Candid, so other canisters, browser resident code and smart phone apps that support Candid can use the actor’s services. The Motoko compiler can consume and produce Candid files, allowing Motoko to seamlessly interact with canisters implemented in other programming languages (provided they support Candid).

For example, the previous Motoko `Counter` actor has the following Candid interface:

``` candid
service Counter : {
  inc : () -> (nat);
}
```

## Orthogonal persistence

The Internet Computer persists the memory and other state of your canister as it executes. Thus the state of a Motoko actor, including its in-memory data structures, survive indefinitely. Actor state does not need to be explicitly "restored" and "saved" to external storage, with every message.

For example, in the following `Registry` actor (canister), that assigns sequential IDs to textual names, the state of the hash table is preserved across calls, even though the state of the actor is replicated across many Internet Computer node machines, and typically not resident in memory.

``` motoko file=./examples/Registry.mo
```

## Upgrades

Motoko provides numerous features to help you leverage orthogonal persistence, including language features that allow you to retain a canister’s data as you upgrade the code of the canister.

For example, Motoko lets you declare certain variables as `stable`. The values of `stable` variables are automatically preserved across canister upgrades.

Consider a stable counter:

``` motoko file=./examples/StableCounter.mo
```

It can be installed, incremented *n* times, and then upgraded, without interruption, to, for example, the richer implementation:

``` motoko file=./examples/StableCounterUpgrade.mo
```

Because `value` was declared `stable`, the current state, *n*, of the service is retained after the upgrade. Counting will continue from *n*, not restart from `0`.

Because the new interface is compatible with the previous one, existing clients referencing the canister will continue to work, but new clients will be able to exploit its upgraded functionality (the additional `reset` function).

For scenarios that can’t be solved using stable variables alone, Motoko provides user-definable upgrade hooks that run immediately before and after upgrade, and allow you to migrate arbitrary state to stable variables.

## And more …​

Motoko provides many other developer productivity features, including subtyping, arbitrary precision arithmetic and garbage collection.

Motoko is not, and is not intended to be, the only language for implementing canister smart contracts. If it doesn’t suit your needs, there is a canister development kit (CDK) for the Rust programming language. Our goal is to enable any language (with a compiler that targets WebAssembly) to be able to produce canister smart contracts that run on the Internet Computer and interoperate with other, perhaps foreign, canister smart contracts through language neutral Candid interfaces.

Its tailored design means Motoko should be the easiest and safest language for coding on the Internet Computer, at least for the forseeable future.

-->
</body>
</html>
