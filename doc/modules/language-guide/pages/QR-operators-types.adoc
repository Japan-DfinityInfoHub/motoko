= Primitive types and operators
:proglang: Motoko
:candid: Candid
:sdk-short-name: DFINITY Canister SDK
:company-id: DFINITY

This section describes the all of the available operators and types that {proglang} supports.
The operators and primitive types described in this section are classified into the following basic categories:

|===
| Category and abbreviation | Supported operations

| Arithmetic (A) | Arithmetic operations
| Logical (L)    | Logical/Boolean operations
| Bitwise (B)    | Bitwise operations
| Ordered (O)    | Comparison operations
| Text (T)       | Concatenation operations
|===

Although these categories provide a basic framework for discussing the operations associated with different types, keep in mind that some types fit into more than one category.
For example, the type `Int` is both arithmetic (A) and ordered (O) and, therefore, supports both arithmetic operations such as addition (`+`) and relational operations such as less than (`<`).

[[syntax-ops-unary]]
== Unary operators

Unary operators are operators that require a single operand and only use that operand to perform computations.

[width="95%",cols="10%,10%,70%",options="header",]
|===
| Operator | Category   | Description

| `+-+`    | Arithmetic | Numeric negation.
| `+++`    | Arithmetic | Numeric identity.
| `+^+`    | Bitwise    | Bitwise negation.
|===

[[syntax-ops-rel]]
== Relational operators

You can use the following relational operators in {proglang} programs.

[width="95%",cols="10%,10%,70%",options="header",]
|===
| Operator | Category | Description
|  `==` | | Equals.
|  `!=` | | Not equals.
| `␣<␣` | Ordered | Less than. Note that the operator must be enclosed in whitespace (as indiated by the `+␣+` charactor).
| `␣>␣` | Ordered | Greater than. Note that the operator must be enclosed in whitespace (as indiated by the `+␣+` charactor).
|  `\<=` | Ordered | Less than or equal to.
|  `>=` | Ordered | Greater than or equal to.
|===

Note that equality (`==`) and inequality (`!=`) do not have categories.
Instead, equality and inequality are applicable to arguments of all
_shared_ types, including non-primitive, compound types such as
immutable arrays, records, and variants.

Equality and inequality are structural and based on the observable content of their operands (as determined by their static type).

[[syntax-ops-num]]
=== Numeric binary operators

|===
| Operator | Category | Description

|  `+` | Arithmetic | Addition
|  `-` | Arithmetic | Subtraction
|  `*` | Arithmetic | Multiplication
|  `/` | Arithmetic | Division
|  `%` | Arithmetic | Modulo
|  `**`| Arithmetic | Exponentiation
|===

[[syntax-ops-bitwise]]
=== Bitwise binary operators

|===
| Operator | Category | Description

| `&`   | Bitwise operations | Bitwise AND
| `\|`   | Bitwise operations | Bitwise OR
| `^`   | Bitwise operations | Exclusive OR
| `<<`  | Bitwise operations | Shift left
| `␣>>` | Bitwise operations | Shift right *(must be preceded by whitespace)*
| `+>>` | Bitwise operations | Signed shift right
| `<<>` | Bitwise operations | Rotate left
| `<>>` | Bitwise operations | Rotate right
|===

[[syntax-ops-string]]
=== Text operators

|===
| Operator | Category | Description

|  `#` | Text | Concatenation
|===

[[syntax-ops-assignment]]
=== Assignment operators

The category listed for the compound assignment operators in the table is the category associated with unary or binary operator.

|===
| Operator| Category| Description

| `:=`   | * | Assignment (in-place update)
| `+=`   | Arithmetic | In-place addition
| `-=`   | Arithmetic | In-place subtraction
| `*=`   | Arithmetic | In-place multiplication
| `/=`   | Arithmetic | In-place division
| `%=`   | Arithmetic | In-place modulo
| `**=`  | Arithmetic | In-place exponentiation
| `&=`   | Bitwise | In-place logical AND
| `\|=`  | Bitwise | In-place logical OR
| `^=`   | Bitwise | In-place exclusive OR
| `<\<=` | Bitwise | In-place shift left
| `>>=`  | Bitwise | In-place shift right
| `+>>=` | Bitwise | In-place signed shift right
| `<<>=` | Bitwise | In-place rotate left
| `<>>=` | Bitwise | In-place rotate right
| `#=`   | Text | In-place concatenation
|===

[[syntax-precedence]]
=== Operator and keyword precedence

The following table defines the relative precedence and associativity of operators and tokens, ordered from lowest to highest precedence.
Tokens on the same line have equal precedence with the indicated associativity.

|===
|Precedence | Associativity | Token

| LOWEST  | none | `if _ _` (no `else`), `loop _` (no `while`)
|(higher)| none | `else`, `while`
|(higher)| right | `:=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, `#=`, `&=`, `\|=`, `^=`, `<\<=`, `>>-`, `<<>=`, `<>>=`
|(higher)| left | `:`
|(higher)| left | `or`
|(higher)| left | `and`
|(higher)| none | `==`, `!=`, `<`, `>`, `\<=`, `>`, `>=`
|(higher)| left | `+`, `-`, `#`
|(higher)| left | `*`, `/`, `%`
|(higher)| left | `\|`
|(higher)| left | `+&+`
|(higher)| left | `+^+`
|(higher)| none | `<<`, `>>`, `<<>`, `<>>`
| HIGHEST | left | `+**+`
|===

[[syntax-programs]]
=== Programs

The syntax of a _program_ `<prog>` is as follows:


```bnf
<prog> ::=             programs
    <imp>;* <dec>;*
```

A program is sequence of imports `<imp>;*` followed by a sequence of declarations `<dec>;*` that ends with an optional actor or actor class declaration.
The actor or actor class declaration determines the main actor, if any, of the program.

For now, compiled programs must obey the following additional restrictions (not imposed on interpreted programs):

* A program can contain only one actor or actor class declaration.
* All actor class declarations should be *anonymous*.
+
THe compiler will report any references to a named actor class as an unavailable identifier.

The restrictions are designed to forbid programmatic actor instantiation and recursion, pending compiler support.

Note that the parameters (if any) of an actor class must have a shared type. For more information, see <<sharability>>.
The parameters of a program's final actor class provide access to the corresponding canister installation argument(s); the {candid} type of this argument is determined by the {candid} projection of the {proglang} type of the class parameter.

[[syntax-imports]]
=== Imports

The syntax of an _import_ `<imp>`  is as follows:

```bnf
<imp> ::= imports
    import <id>? =? <url>

<url> ::=
    "<filepath>"                      import module from relative <filepath>.mo
    "mo:<package-name>/<filepath>"    import module from package
    "canister:<canisterid>"           import external actor by <canisterid>
    "canister:<name>"                 import external actor by <name>
```

An import introduces a resource named '<id>?' referring to a local source module, module from a package of modules, or canister (imported as an actor).

[[syntax-libraries]]
=== Libraries

The syntax of a _library_ (that can be referenced in an import) is as follows:

```bnf
<lib> ::=                                                                                       library
    <imp>;* module <id>? <obj-body>                                                               module
    <imp>;* <shared-pat>? actor class <id> <typ-params>? <pat> (: <typ>)? <class-body>            actor class
```

A library `<lib>` is a sequence of imports `<imp>;*` followed by:

* a named or anonymous (module) declaration; or
* a named actor class declaration.

Libraries stored in `.{ext}` files may be referenced by `import` declarations.

In a module library, the optional name `<id>?` is only significant within the library and does not determine the name of the library when imported.
Instead, the imported name of a library is determined by the `+import+` declaration, giving clients of the library the freedom to
choose library names (for example, to avoid clashes).

An actor class library, because it defines both a type constructor and a function with name `<id>`, is imported as a module defining both a type and a function named `<id>`.
The name `<id>` is mandatory and cannot be omitted.
The imported actor class constructor is asynchronous, with return type `async T`. Here `T` is the inferred or supplied type of the class body.
Because actor construction is asynchronous, an instance of an imported actor class can only be created in an asynchronous context
(that is, in the body of a (non-`query`) `shared` function or `async` expression).


[[syntax-decls]]
=== Declaration syntax

The syntax of a _declaration_ is as follows:

```bnf
<dec> ::=                                                                              declaration
  <exp>                                                                                  expression
  ignore <exp>                                                                           ignore
  let <pat> = <exp>                                                                      immutable
  var <id> (: <typ>)? = <exp>                                                            mutable
  <sort> <id>? =? <obj-body>                                                             object
  <shared-pat>? func <id>? <typ-params>? <pat> (: <typ>)? =? <exp>                       function
  type <id> <typ-params>? = <typ>                                                        type
  <shared-pat>? <sort>? class <id>? <typ-params>? <pat> (: <typ>)? <class-body>          class

<obj-body> ::=           object body
   { <dec-field>;* }       field declarations

<class-body> ::=         class body
    = <id>? <obj-body>     object body, optionally binding <id> to _this_ instance
    <obj-body>             object body
```

The syntax of a shared function qualifier with call-context pattern is as follows:

```bnf
<shared-pat> ::=
  shared query? <pat>?
```

For `<shared-pat>`, an absent `<pat>?` is shorthand for the wildcard pattern `_`.

```bnf
<dec-field> ::=                                object declaration fields
  <vis>? <stab>? <dec>                           field

<vis> ::=                                      field visibility
  public
  private
  system

<stab> ::=                                     field stability (actor only)
  stable
  flexible
```

The _visibility_ qualifier `<vis>?` determines the accessibility of every field `<id>` declared by `<dec>`:

* An absent `<vis>?` qualifier defaults to `private` visibility.
* Visibility `private` restricts access to `<id>` to the enclosing object, module or actor.
* Visibility `public` extends `private` with external access to `<id>` using the dot notation `<exp>.<id>`.
* Visibility `system` extends `private` with access by the run-time system.
* Visibility `system` _may only_ appear on `func` declarations that are actor fields, and  _must not_ appear anywhere else.

The _stability_ qualifier `<stab>` determines the _upgrade_ behaviour of actor fields:

* A stability qualifier _should_ appear on `let` and `var` declarations that are actor fields.
  An absent stability qualifier defaults to `flexible`.
* `<stab>` qualifiers must not appear on fields of objects or modules.
* The pattern in a `stable let <pat> = <exp>` declaration must be _simple_ where,  a pattern `pat` is  simple if it (recursively) consists of
** a variable pattern `<id>`, or
** an annotated simple pattern `<pat> : <typ>`, or
** a parenthesised simple pattern `( <pat> )`.

[[syntax-expressions]]
=== Expression syntax

The syntax of an _expression_ is as follows:

```bnf
<exp> ::=                                      expressions
  <id>                                           variable
  <lit>                                          literal
  <unop> <exp>                                   unary operator
  <exp> <binop> <exp>                            binary operator
  <exp> <relop> <exp>                            binary relational operator
  ( <exp>,* )                                    tuple
  <exp> . <nat>                                  tuple projection
  ? <exp>                                        option injection
  { <exp-field>;* }                              object
  # id <exp>?                                    variant injection
  <exp> . <id>                                   object projection/member access
  <exp> := <exp>                                 assignment
  <unop>= <exp>                                  unary update
  <exp> <binop>= <exp>                           binary update
  [ var? <exp>,* ]                               array
  <exp> [ <exp> ]                                array indexing
  <shared-pat>? func <func_exp>                  function expression
  <exp> <typ-args>? <exp>                        function call
  { <dec>;* }                                    block
  not <exp>                                      negation
  <exp> and <exp>                                conjunction
  <exp> or <exp>                                 disjunction
  if <exp> <exp> (else <exp>)?                   conditional
  switch <exp> { (case <pat> <exp>;)+ }          switch
  while <exp> <exp>                              while loop
  loop <exp> (while <exp>)?                      loop
  for ( <pat> in <exp> ) <exp>                   iteration
  label <id> (: <typ>)? <exp>                    label
  break <id> <exp>?                              break
  continue <id>                                  continue
  return <exp>?                                  return
  async <exp>                                    async expression
  await <exp>                                    await future (only in async)
  throw <exp>                                    raise an error (only in async)
  try <exp> catch <pat> <exp>                    catch an error (only in async)
  assert <exp>                                   assertion
  <exp> : <typ>                                  type annotation
  <dec>                                          declaration
  debug <exp>                                    debug expression
  actor <canister-id-exp>                        actor reference
  ( <exp> )                                      parentheses
```

[[syntax-patterns]]
=== Patterns

The syntax of a _pattern_ is as follows:

....
<pat> ::=                                      patterns
  _                                              wildcard
  <id>                                           variable
  <unop>? <lit>                                  literal
  ( <pat>,* )                                    tuple or brackets
  { <pat-field>;* }                              object pattern
  # <id> <pat>?                                  variant pattern
  ? <pat>                                        option
  <pat> : <typ>                                  type annotation
  <pat> or <pat>                                 disjunctive pattern

<pat-field> ::=                                object pattern fields
  <id> = <pat>                                   field
  <id>                                           punned field
  <id> : <typ>                                   typed punned field
....
